{"noir_version":"0.32.0+c679f01a19b02ad2ac2287c8e699b46887f7872c","hash":14338700290566622717,"abi":{"parameters":[{"name":"body_text","type":{"kind":"array","length":1054,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"substring_text","type":{"kind":"array","length":279,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"position","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"body_length","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"substring_length","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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BfluQb5bkO8W5LsF+W5BvluQ7xbkuwX5bkG+W5DvFuS7BfluQb5bkO8W5LsF+W5BvluQ7xbkuwX5bkG+W5DvFuS7BfluQb5bkO8W5LsF+W5BvluQ7xbkuwX5bkO+25DvNuS7DfluQ77bkO825LsN+W5DvtuQ7zbkuw35bkO+25DvNuS7DfluQ77bkO825LsN+W5DvtuQ7zbkuw35bkO+25DvNuS7DfluQ77bkO825LsN+W5DvtuQ7zbkuw35bkO+25DvNuS7DfluQ77bkO825LsN+W5DvtuQ7zbkuw35bkO+25DvNuS7DfluQ77bkO825LsN+W5DvtuQ7zbkuw35bkO+25DvNuS7DfluQ77bkO825LsN+W5DvtuQ7zbkuw35bkO+25DvNuS7DfluQ77bkO825LsN+W5DvtuQ7zbkuw35bkO+25DvNuS7DfluQ77bkO825LsN+W5DvtuQ7zbkuw35bkO+25DvNuS7DfnuQL47kO8O5LsD+e5AvjuQ7w7kuwP57kC+O5DvDuS7A/nuQL47kO8O5LsD+e5AvjuQ7w7kuwP57kC+O5DvDuS7A/nuQL47kO8O5LsD+e5AvjuQ7w7kuwP57kC+O5DvDuS7A/nuQL47kO8O5LsD+e5AvjuQ7w7kuwP57kC+O5DvDuS7A/nuQL47kO8O5LsD+e5AvjuQ7w7kuwP57kC+O5DvDuS7A/nuQL47kO8O5LsD+e5AvjuQ7w7kuwP57kC+O5DvDuS7A/nuQL47kO8O5LsD+e5AvjuQ7w7kuwP57kC+O5DvDuS7A/nuQL47kO8O5LsD+e5AvjuQ7w7kuwP57kC+O5DvDuS7A/nuQL47kO8O5LsD+e6FfPdCvnsh372Q717Idy/kuxfy3Qv57oV890K+eyHfvZDvXsh3L+S7F/LdC/nuhXz3Qr57Id+9kO9eyHcv5LsX8t0L+e6FfPdCvnsh372Q717Idy/kuxfy3Qv57oV890K+eyHfvZDvXsh3L+S7F/LdC/nuhXz3Qr57Id+9kO9eyHcv5LsX8t0L+e6FfPdCvnsh372Q717Idy/kuxfy3Qv57oV890K+eyHfvZDvXsh3L+S7F/LdC/nuhXz3Qr57Id+9kO9eyHcv5LsX8t0L+e6FfPdCvnsh372Q717Idy/kuxfy3Qv57oV890K+eyHfvZDvXsh3L+S7F/LdC/nuhXz3Qr57Id+9kO9eyHcv5LsX8t0L+e6FfPdCvnsh372Q754XBLwfAw8daHSg04FBByYdWHRg04FDB1LlHKqcQ5VzqHIOVc6hyjlUOYcq51DlHKqcQ5VjVDlGlWNUOUaVY1Q5RpVjVDlGlWNUOUaV41Q5TpXjVDlOleNUOU6V41Q5TpXjVDlOlRNUOUGVE1Q5QZUTVDlBlRNUOUGVE1Q5QZWTVDlJlZNUOUmVk1Q5SZWTVDlJlZNUOUmVU1Q5RZVTVDlFlVNUOUWVU1Q5RZVTVDlFldNUOU2V01Q5TZXTVDlNldNUOU2V01Q5TZUzVDlDlTNUOUOVg6Dx+SOqyT+GFRvWbNiwYRcNQ5X4x7DDhhkb5mwYU4kxlRhTiTGVGFOJMZU4U4kzlThTiTOVOFOJM5U4U4kzlThTiTOVBFNJMJUEU0kwlQRTSTCVBFNJMJUEU0kwlSRTSTKVJFNJMpUkU0kylSRTSTKVJFNJMpUUU0kxlRRTSTGVFFNJMZUUU0kxlRRTSTGVNFNJM5U0U0kzlTRTSTOVNFNJM5U0U0kzlQxTyTCVDFPJMJXASniYSoapZJhKhqlkmEouU8llKrlMJZep5DKVXKaSy1RymUouU8llKjmvFxx34DiD4xyOg2jtBdna39oo9fEf/p9/+J//9A//5Z//8V8/Bvz0v/2vP/3Xf/unf/nTX/7jv/2//+PP/8vH3/5/","file_map":{"23":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field/mod.nr"},"32":{"source":"mod hash;\nmod aes128;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod embedded_curve_ops;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod convert;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\nmod bigint;\nmod runtime;\nmod meta;\nmod append;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(verification_key: [Field], proof: [Field], public_inputs: [Field], key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\n","path":"std/lib.nr"},"47":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n","path":"std/slice.nr"},"53":{"source":"use crate::substring;\nuse crate::substring::get_lt_predicate;\n\nunconstrained pub fn search<let N: u64, let M: u64>(\n    haystack: [u8; N],\n    needle: [u8; M],\n    haystack_length: u64,\n    needle_length: u64\n) -> (bool, u64) {\n    let mut found = false;\n    let mut found_index: u64 = 0;\n    for i in 0..haystack_length - needle_length {\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    (found, found_index)\n}\n\n/**\n * @brief validate the body text contains zero-values for all indices >= byte_length\n * @note NOT NEEDED. Consider removing. Values beyond byte_length are not used in matching algorithm so no need to constrain them\n **/\nfn validate_body<let BODYBYTES: u64, let BODYCHUNKS: u64>(data: [u8; BODYBYTES], length: u64, _: [Field; BODYCHUNKS]) {\n    // we want a conditional assert for cases where i >= length\n    // if i >= length we want to assert that data = 0\n    let mut delta: Field = length as Field;\n    for i in 0..BODYBYTES {\n        let predicate = substring::lt(i, length);\n        let predicate = get_lt_predicate(i, length);\n\n        let lt_parameter = 2 * (predicate as Field) * delta - predicate as Field - delta;\n        lt_parameter.assert_max_bit_size(14);\n        delta = delta - 1;\n        std::as_witness(delta);\n\n        // assert that if predicate = 0 then byte = 0\n        assert(data[i] as Field * predicate as Field == data[i] as Field);\n    }\n}\n","path":"/Users/zac/noir_string_search/src/utils.nr"},"54":{"source":"struct SubString<let MaxBytes: u64> {\n    body: [u8; MaxBytes],\n    byte_length: u64,\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    let mut result: u8 = 0;\n    if (predicate) {\n        result = lhs;\n    } else {\n        result = rhs;\n    }\n    result\n}\n\nfn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    let result = __conditional_select(lhs, rhs, predicate);\n    let result_f = result as Field;\n    let lhs_f = lhs as Field;\n    let rhs_f = rhs as Field;\n\n    let diff = lhs_f - rhs_f;\n    std::as_witness(diff);\n    assert((predicate as Field) * (diff) + rhs_f == result_f);\n    result\n}\n\nunconstrained fn get_lt_predicate(x: u64, y: u64) -> bool {\n    x < y\n}\n\nunconstrained fn get_lt_predicate_f(x: Field, y: Field) -> bool {\n    let a = x as u64;\n    let b = y as u64;\n    let r = a < b;\n    r\n}\n\npub fn lt(x: u64, y: u64) -> bool {\n    let predicate = get_lt_predicate(x, y);\n    let delta = y as Field - x as Field;\n    let lt_parameter = 2 * (predicate as Field) * delta - predicate as Field - delta;\n    lt_parameter.assert_max_bit_size(14);\n\n    predicate\n}\n\npub fn lt_f(x: Field, y: Field) -> bool {\n    let predicate = get_lt_predicate_f(x, y);\n    let delta = y as Field - x as Field;\n    let lt_parameter = 2 * (predicate as Field) * delta - predicate as Field - delta;\n    lt_parameter.assert_max_bit_size(14);\n\n    predicate\n}\n\n// need to convert SubString into Chunks\n\n// 3209 -> 3213 = 4\nimpl<let MaxBytes: u64> SubString<MaxBytes> {\n    fn new<let InputBytes: u64>(input: [u8; InputBytes], input_length: u64) -> Self {\n        assert(InputBytes <= MaxBytes);\n        assert(input_length <= InputBytes);\n        let mut body: [u8; MaxBytes] = [0; MaxBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    fn concat<let OtherBytes: u64>(self, other: SubString<OtherBytes>) -> Self {\n        assert(\n            OtherBytes <= MaxBytes, \"SubString::concat. SubString being concatted has larger max length. Try swapping params around and call prepend\"\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxBytes, \"SubString::concat, concatenated string exceeds MaxBytes\"\n        );\n        let mut body = self.body;\n        let offset: u64 = self.byte_length;\n        for i in 0..OtherBytes {\n            let predicate = lt(i, other.byte_length); // 3.36 gates\n\n            let lhs_index = predicate as Field * (i as Field + offset as Field); // ensure array index does not overflow\n            let lhs = body[lhs_index];\n            let rhs = other.body[i];\n            // an if statement costs 6.5 gates, this method costs 3.25 gates\n            let byte: u8 = conditional_select(lhs, rhs, predicate);\n            body[i + offset] = byte;\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\n","path":"/Users/zac/noir_string_search/src/substring.nr"},"55":{"source":"// fn main(x: Field, y: pub Field) {\n//     assert(x != y);\n// }\n\n// #[test]\n// fn test_main() {\n//     main(1, 2);\n//     // Uncomment to make test fail\n//     // main(1, 1);\n// }\nmod utils;\nmod substring;\n\nglobal BODYCHUNKS = 34;\n\nglobal MAXSUBSTRINGBYTES = 93;\nglobal MAXSUBSTRINGCHUNKS = 3;\n\nuse substring::SubString;\n\nstruct StringBody<let BODYBYTES: u64, let BODYCHUNKS: u64> {\n    body: [u8; BODYBYTES],\n    chunks: [Field; BODYCHUNKS],\n    byte_length: u64\n}\n\nstruct StringTarget {\n    body: [u8; MAXSUBSTRINGBYTES],\n    chunks: [Field; MAXSUBSTRINGCHUNKS],\n    byte_length: u64\n}\n\nunconstrained fn get_lt_predicate(x: u64, y: u64) -> bool {\n    x < y\n}\n\nimpl<let BODYBYTES: u64, let BODYCHUNKS: u64> StringBody<BODYBYTES, BODYCHUNKS> {\n\n    fn compute_chunks(body: [u8; BODYBYTES]) -> [Field; BODYCHUNKS] {\n        let mut chunks: [Field; BODYCHUNKS] = [0; BODYCHUNKS];\n        for i in 0..BODYCHUNKS {\n            let mut limb: Field = 0;\n            for j in 0..31 {\n                limb *= 256;\n                limb += body[i * 31 + j] as Field;\n            }\n            chunks[i] = limb;\n            std::as_witness(chunks[i]);\n        }\n        chunks\n    }\n\n    fn new<let SubStringBytes: u64>(haystack: SubString<SubStringBytes>) -> Self {\n        assert(SubStringBytes <= BODYBYTES, \"StringBody::new input max length too large!\");\n        let mut body: [u8; BODYBYTES] = [0; BODYBYTES];\n        for i in 0..SubStringBytes {\n            body[i] = haystack.body[i];\n        }\n        StringBody { body, chunks: StringBody::compute_chunks(body), byte_length: haystack.byte_length }\n    }\n\n    fn from_array(data: [u8; BODYBYTES], length: u64) -> Self {\n        assert(length <= BODYBYTES);\n        StringBody { body: data, chunks: StringBody::compute_chunks(data), byte_length: length }\n    }\n\n    fn convert_chunk_to_bytes(self, chunk_idx: u64) -> [u8; 31] {\n        let chunk = self.chunks[chunk_idx];\n        chunk.to_be_bytes(31).as_array()\n    }\n\n    // substring has a maximum number of bytes\n    // which requires a maximum number of chunks\n    // when aligning the substring chunks with the body chunks, we may need 1 additional chunk\n    // todo hmm\n    fn substring_match<let SSBYTES: u64, let PADDED_SUBSTRING_BYTES: u64, let PADDED_SUBSTRING_CHUNKS: u64>(\n        self,\n        substring: SubString<SSBYTES/*, PADDED_SUBSTRING_BYTES*/>,\n        _: [Field; PADDED_SUBSTRING_CHUNKS],\n        __: u64\n    ) -> bool {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text \n        let (found, position): (bool, u64) = utils::search(\n            self.body,\n            substring.body,\n            self.byte_length,\n            substring.byte_length\n        );\n        assert(found == true, \"substring not present in main text!\");\n        assert(\n            position + substring.byte_length <= self.byte_length, \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\"\n        );\n        let substring_length = substring.byte_length;\n\n        let chunk_index: u64 = position / 31;\n        let chunk_offset: u64 = position % 31;\n\n        let num_bytes_in_first_chunk = 31 - chunk_offset;\n        let mut num_remaining_bytes: u64 = 0;\n        if (substring_length >= num_bytes_in_first_chunk) {\n            num_remaining_bytes = (substring_length - num_bytes_in_first_chunk);\n        }\n        let num_full_chunks = num_remaining_bytes / 31;\n\n        let mut starting_substring_byte_index_of_final_chunk: u64 = 0;\n\n        if (substring_length >= num_bytes_in_first_chunk) {\n            starting_substring_byte_index_of_final_chunk = num_full_chunks * 31 + num_bytes_in_first_chunk;\n        } else {\n            starting_substring_byte_index_of_final_chunk = 0;\n        }\n        let body_chunk_index_of_final_chunk = num_full_chunks + chunk_index + 1; // hmm should this be +1?\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n\n            when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n\n            a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n\n            Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n\n            The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n\n            If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // GET INITIAL CHUNK\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let body_bytes: [u8; 31] = self.chunks[chunk_index].to_be_bytes(31).as_array();\n        let offset_to_first_needle_byte_in_chunk: Field = chunk_offset as Field;\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: Field = i as Field;\n            let predicate: Field = substring::lt_f(i as Field, offset_to_first_needle_byte_in_chunk) as Field;\n            let lhs: Field = body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = (1 - predicate) * (idx - offset_to_first_needle_byte_in_chunk);\n            let rhs: Field = substring.body[substring_idx] as Field;\n            let byte: Field = predicate * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // GET FINAL CHUNK\n        let mut new_initial_chunk: [Field; 31] = [0; 31];\n        let merge_chunks = (num_bytes_in_first_chunk > substring_length);\n\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = 0;\n\n        // this nasty!\n        if (substring_length >= num_bytes_in_first_chunk) {\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = num_full_chunks + chunk_index + 1;\n        } else {\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index;\n        }\n\n        let final_haystack_chunk = self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n        let body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes(31).as_array();\n        // let body_bytes = self.convert_chunk_to_bytes(chunk_index_of_final_haystack_chunk_with_matching_needle_bytes);\n        println(f\"body bytes = {body_bytes}\");\n        for i in 0..31 {\n            let lhs_index = starting_substring_byte_index_of_final_chunk as Field + i as Field;\n            let predicate = substring::lt_f(lhs_index, substring_length as Field);\n            let lhs: Field = substring.body[lhs_index] as Field;\n            let rhs: Field = body_bytes[i] as Field;\n            let byte: Field = predicate as Field * (lhs - rhs) + rhs;\n            final_chunk[i] = byte;\n            // }\n\n            // for i in 0..31 {\n            // let predicate = (starting_substring_byte_index_of_final_chunk + i) < substring_length;\n            let lhs_index = predicate as Field * (lhs_index);\n\n            let lhs = initial_chunk[lhs_index];\n            let rhs = body_bytes[i] as Field;\n            let byte: Field = lhs as Field * predicate as Field + rhs as Field * (1 - predicate as Field);\n            //  initial_chunk[i] = \n            std::as_witness(byte);\n            let val = (byte as Field * merge_chunks as Field)\n                + initial_chunk[(i as Field) as Field * (1 - merge_chunks as Field)];\n            std::as_witness(val);\n            new_initial_chunk[i] = val;\n        }\n        println(f\"initial chunk = {initial_chunk}\");\n        println(f\"new initial chunk = {new_initial_chunk}\");\n        let mut initial_chunk_field: Field = 0;\n        for i in 0..31 {\n            initial_chunk_field *= 256;\n            initial_chunk_field += new_initial_chunk[i];\n        }\n        std::as_witness(initial_chunk_field);\n        let mut final_chunk_field: Field = 0;\n        for i in 0..31 {\n            final_chunk_field *= 256;\n            final_chunk_field += final_chunk[i];\n        }\n        final_chunk_field = initial_chunk_field * merge_chunks as Field + (final_chunk_field * (1 - merge_chunks as Field));\n        let lhs = initial_chunk_field;\n        let rhs = self.chunks[chunk_index];\n        assert(lhs == rhs);\n\n        println(f\"merge chunks = {merge_chunks}\");\n        println(f\"final_chunk_field = {final_chunk_field}\");\n        let lhs = final_chunk_field;\n        let rhs = final_haystack_chunk;\n        assert(lhs == rhs);\n\n        // // constituting body chunks is hard because we need to read from unknown index = 2 gates = womp\n        let mut substring_chunks: [Field; PADDED_SUBSTRING_CHUNKS] = [0; PADDED_SUBSTRING_CHUNKS];\n\n        for i in 0..PADDED_SUBSTRING_CHUNKS {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let mut byte = substring.body[num_bytes_in_first_chunk + (i * 31) + j];\n                slice += byte as Field;\n            }\n            substring_chunks[i] = slice;\n        }\n\n        let body_chunk_offset = chunk_index + 1;\n        for i in 0..PADDED_SUBSTRING_CHUNKS {\n            let mut lhs = substring_chunks[i];\n\n            let rhs = self.chunks[i + body_chunk_offset];\n\n            let predicate = i < num_full_chunks;\n            lhs = lhs * (predicate as Field) + rhs * (1 - predicate as Field);\n            assert(lhs == rhs);\n        }\n        true\n    }\n}\n\n#[test]\nfn test() {\n    let mut body_text: [u8; 124] = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\n        10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\n        50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69,\n        70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\n        90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109,\n        110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123\n    ];\n    // let mut body_text: [u8; 124] = [0; 124];\n    // for i in 0..124 {\n    //     body_text[i] = body_text_e[123 - i];\n    // }\n    // let substring_text: [u8; 62] = [\n    //     10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n    //     20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n    //     30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n    //     40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\n    //     50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n    //     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    //     0, 0\n    // ];\n    let substring_text: [u8; 122] = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\n        10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\n        50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    ];\n    // let res2 = dep::std::hash::sha256_var(body_text, 50);\n    // println(f\"{res2}\");\n    let mut Body: StringBody<124, 4> = StringBody::from_array(body_text, 124);\n    let mut substring: SubString<122/*,2*/> = SubString::new(substring_text, 62);\n    // StringBody { body: substring_text, chunks: [0; 2], byte_length: 62 };\n    let r = Body.substring_match(substring, [0; 2], 0);\n    assert(r == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let mut body_text: [u8; 124] = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\n        10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\n        50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69,\n        70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\n        90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109,\n        110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123\n    ];\n    let substring_text: [u8; 122] = [\n        2, 3, 4, 5, 6, 7, 8, 9,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    ];\n    let mut Body: StringBody<124, 4> = StringBody::from_array(body_text, 124);\n    let mut substring: SubString<122/*,2*/> = SubString::new(substring_text, 8);\n    let r = Body.substring_match(substring, [0; 2], 0);\n    assert(r == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let mut body_text: [u8; 124] = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\n        10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\n        50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69,\n        70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\n        90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109,\n        110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123\n    ];\n    let substring_text: [u8; 122] = [\n        2, 3, 4, 5, 6, 7, 8, 9,\n        10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n        30, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    ];\n    let mut Body: StringBody<124, 4> = StringBody::from_array(body_text, 124);\n    let mut substring: SubString<122/*,2*/> = SubString::new(substring_text, 29);\n    let r = Body.substring_match(substring, [0; 2], 0);\n    assert(r == true);\n}\n// 7042 = 1, 1\n// 7190 = 2, 1\n// 7339 = 3, 1\n// 7708 = 3, 2\n\n// 7708 -> 11724 => 30, 2\n// 4016 diff for 27 chunks = 837 bytes = 4.8 per byte or 130 per chunk. seems bad?\nglobal BODYLEN = 1054;\nglobal BODYCHUNK = 34;\nglobal SUBSTRINGLEN = 279;\nglobal SUBSTRINGCHUNK = 9;\n// 841 - 692 = 149 argh\n// 4098 -> 4137 = 39 gates. 31 * 1.25 for u8 bytes = 39 \nunconstrained fn get_test_stringbody(\n    body_text: [u8; BODYLEN],\n    substring_text: [u8; SUBSTRINGLEN],\n    _: u64,\n    body_length: u64,\n    substring_length: u64\n) -> (StringBody<BODYLEN, BODYCHUNK>, StringBody<SUBSTRINGLEN,SUBSTRINGCHUNK>) {\n    let mut Body: StringBody<BODYLEN, BODYCHUNK> = StringBody::from_array(body_text, body_length);\n\n    let mut SubString: StringBody<SUBSTRINGLEN,SUBSTRINGCHUNK> = StringBody { body: substring_text, chunks: [0; SUBSTRINGCHUNK], byte_length: substring_length };\n    (Body, SubString)\n}\n\n// 3215 -> 3230 = 15 gates per it\nglobal OtherBytes = 20;\nglobal MaxBytes = 32;\n\n// fn main(body: [u8; MaxBytes], other_body: [u8; MaxBytes], byte_length: u64, other_byte_length: u64) {\n//     let A : substring::SubString<MaxBytes> = substring::SubString::new(body, byte_length);\n//     let B : substring::SubString<OtherBytes> = substring::SubString::new(other_body, other_byte_length);\n\n//     let C = A.concat(B);\n//     println(f\"{C}\");\n//     // assert(\n//     //     OtherBytes <= MaxBytes, \"SubString::concat. SubString being concatted has larger max length. Try swapping params around and call prepend\"\n//     // );\n//     // assert(\n//     //     byte_length + other_byte_length <= MaxBytes, \"SubString::concat, concatenated string exceeds MaxBytes\"\n//     // );\n//     // //  let mut body = body;\n//     // let offset: u64 = byte_length;\n//     // for i in 0..OtherBytes {\n//     //     let predicate = i < other_byte_length; // TODO optimize\n//     //     let lhs = body[i as Field + offset as Field];\n//     //     let rhs = other_body[i];\n//     //     println(f\"{predicate}\");\n//     //     println(f\"{lhs}\");\n//     //     println(f\"{rhs}\");\n//     //     // 1 it = 2989\n//     //     // 2 it = 3004 = 15 gates\n//     //     // 1 it = 2982\n//     //     // 2 it = 2991 = 9 gates => 6 gates\n//     //     //    let byte: Field = (lhs as Field - rhs as Field) * predicate as Field + rhs as Field;\n//     //     //    println(f\"{byte}\");\n//     //     //    let byte: u8 = conditional_select(lhs, rhs, predicate);\n//     //     // (lhs - rhs) * predicate + rhs = 2 gates\n//     //     let mut byte: u8 = 0;\n//     //     if (predicate) {\n//     //         byte = lhs;\n//     //     } else {\n//     //         byte = rhs;\n//     //     }\n//     //     println(f\"{byte}\");\n//     //     // 13 / 2 = 6.5\n//     //     //   body[i + offset] = byte;\n//     // }\n//     //   println(f\"{body}\");\n//     //  SubString { body, byte_length: self.byte_length + other_byte_length }\n// }\n\nfn main(\n    body_text: [u8; BODYLEN],\n    substring_text: [u8; SUBSTRINGLEN],\n    position: u64,\n    body_length: u64,\n    substring_length: u64\n) {\n    (position as Field).assert_max_bit_size(14);\n    //   for i in 0..1 {\n    // for i in 0..124 {\n    //     body_text[i] = body_text[i] + 1;\n    // }\n    // for i in 0..900 {\n    //     substring_text[i] = substring_text[i] + 1;\n    // }\n    //  let mut Body = StringBody::validate_body(body_text, body_length, [0; 40]);\n    let mut Body: StringBody<BODYLEN, BODYCHUNK> = StringBody::from_array(body_text, body_length);\n\n    let mut SubString: SubString<SUBSTRINGLEN> = SubString::new(substring_text, substring_length);\n    //vStringBody { body: substring_text, chunks: [0; SUBSTRINGCHUNK], byte_length: substring_length };\n\n    assert(Body.chunks[position as Field] != 0); // this adds ~600 gates because we instantiate as ROM array\n    // let (Body, SubString) = get_test_stringbody(\n    //     body_text,\n    //     substring_text,\n    //     position,\n    //     body_length,\n    //     substring_length\n    // );\n    let r = Body.substring_match(SubString, [0; SUBSTRINGCHUNK], position);\n    println(f\"{SubString}\");\n    println(f\"{r}\");\n}\n// 4574 to 6578 = 2002\n// 6963 to 15412 = 8449 for 1860 bytes , searching 610\n\n// 110,55 to 11,455 = 400 for 31 bytes = 13 gates per byte. meh\n#[test]\nunconstrained fn test_partial_match() {\n    let mut foo: [u8; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut bar: [u8; 3] = [4, 5, 6];\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 8192] = Engine.get_random_bytes();\n    let mut bar: [u8; 512] = Engine.get_random_bytes();\n    println(f\"{foo}\");\n    println(f\"{bar}\");\n    let (res, _) = utils::search(foo, bar, 10, 3);\n\n    assert(res == false);\n}\n\nstruct DebugRandomEngine {\n    seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes(32).as_array();\n        let hash: [u8; 32] = dep::std::hash::sha256(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    unconstrained fn get_random_bytes<let NBytes: u64>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u64;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n\n","path":"/Users/zac/noir_string_search/src/main.nr"}},"names":["main"]}